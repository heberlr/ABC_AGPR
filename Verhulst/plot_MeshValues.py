import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import (inset_axes, InsetPosition, mark_inset)
import pickle

def ConvertMesh_matplotlib(iteration):
    with open('AGPR/MeshValues.pkl', 'rb') as f:
      dict = pickle.load(f)
    ParMesh = dict['Mesh']
    PosNode = dict['Nodes_Element']
    GPstd = dict[iteration]['GPstdNodes']
    StdElem = dict[iteration]['StdElements']
    # Mesh[i,Par] # parameter value in node i (number of parameter = 2)
    # PosNode[k,:] # nodes which generate element k
    # sigma_element[k] # value of std on element
    NumElements = PosNode.shape[0]
    # pcolormesh assignature
    # (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
    #                       +-----+
    #                       |     |
    #                       +-----+
    #     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
    # shading='flat' the dimensions of X and Y should be one greater than those of C, and the quadrilateral is colored due to the value at C[i, j]
    Par1 = np.linspace(np.min(ParMesh[:,0]),np.max(ParMesh[:,0]),int(np.sqrt(NumElements))+1) # same number of partions for each parameter
    Par2 = np.linspace(np.min(ParMesh[:,1]),np.max(ParMesh[:,1]),int(np.sqrt(NumElements))+1)
    Par1p, Par2p = np.meshgrid(Par1, Par2)
    sigma_element = np.zeros(shape=(Par1p.shape[0]-1,Par1p.shape[1]-1))

    def find_idx_close(small_array,big_array): # return idxs from big array
        return np.argwhere(
        np.isclose(small_array, big_array[:, None, :]).all(-1).any(-1)
    ).reshape(-1)
    for i in range(Par1p.shape[0]-1):
        for j in range(Par1p.shape[1]-1):
            MeshRefNode = np.array([[Par1p[i,j],Par2p[i,j]]])
            IndxNode = find_idx_close(MeshRefNode,ParMesh) # find node AGPR associate to mesh matplotlib
            IndElem = np.argwhere(IndxNode[0] == PosNode[:,0]) # find element generated by the first node in AGPR mesh
            # if ( IndxNode[0] == 0 ): print(f"{i} and {j}: Matplolib mesh: {MeshRefNode}, AGPR mesh: {ParMesh[IndxNode,:]}, Element idx: {IndElem}, Std of element {StdElem[IndElem]}")
            sigma_element[i,j] = StdElem[IndElem]
    # print(f"Max std Element: {np.argmax(StdElem)} value: {np.max(StdElem)} -- Node: {PosNode[np.argmax(StdElem),:]}")
    # print(f"Max std Element: {np.argmax(sigma_element)} -- Node: {PosNode[np.argmax(sigma_element),:]}")
    # print(f"Max std GPR: {np.argmax(GPstd)} -- Node: {ParMesh[np.argmax(GPstd),:]}")
    return Par1p,Par2p,sigma_element

def SamplesByIteraction(iteration):
    with open('AGPR/Dictionary.pkl', 'rb') as f:
      dictSamples = pickle.load(f)
    MatrixPar = dictSamples['samples_parameters']
    DiffSTD = dictSamples['difference_std']
    NumInitialSamples = len(MatrixPar)- len(DiffSTD)+1
    # print(len(MatrixPar),len(DiffSTD))
    return MatrixPar[:NumInitialSamples+iteration,:]

def PlotMesh(iteration,Show=False):
      Par1p,Par2p,sigma_element = ConvertMesh_matplotlib(iteration)
      fig, ax = plt.subplots(1, 1)
      pcm = ax.pcolormesh(Par1p, Par2p, sigma_element, vmin=0, vmax=0.6, cmap='binary') # RdBu_r
      fig.colorbar(pcm, ax=ax,label=r'$\sigma_e$')
      Samples = SamplesByIteraction(iteration)
      if (iteration == 0):
          ax.scatter(Samples[:,0], Samples[:,1], c='#ff0800',s=20.0, marker='o')
      else:
          ax.scatter(Samples[:-1,0], Samples[:-1,1], c='#ff0800',s=20.0, marker='o',alpha=0.3)
          ax.scatter(Samples[-1,0], Samples[-1,1], c='#ff0800',s=40.0, marker='o')
          # print(Samples[-1,:])
      dt = [0.01*(np.max(Par1p) - np.min(Par1p)), 0.01*(np.max(Par2p) - np.min(Par2p))]
      plt.xlim((np.min(Par1p)-dt[0],np.max(Par1p)+dt[0]))
      plt.ylim((np.min(Par2p)-dt[1],np.max(Par2p)+dt[1]))
      plt.xlabel(r'$r$')
      plt.ylabel(r'$K$')
      plt.title(f'Iteration {iteration}')
      if (Show): plt.show()
      else:
        plt.savefig('Figure_%04d.jpg'%iteration, dpi=120, bbox_inches='tight')
        plt.close()

def PlotAGPR_Convergence():
    with open('AGPR/Dictionary.pkl', 'rb') as f:
      dict = pickle.load(f)
    DiffSTD = dict['difference_std']
    fig, ax = plt.subplots(1, 1,figsize=(8,4))
    iteration = np.arange(0,len(DiffSTD),1)
    ax.plot(iteration,DiffSTD, marker='.', color='r', markersize=5)
    ax.set_xlabel('iteration number')
    ax.set_ylabel(r'$d_{\sigma}$')
    ax.set_yscale('log')

    # Create a set of inset Axes: these should fill the bounding box allocated to them.
    ax2 = plt.axes([0,0,1,1])
    # Manually set the position and relative size of the inset axes within ax1
    ip = InsetPosition(ax, [0.4,0.4,0.5,0.5])
    ax2.set_axes_locator(ip)
    # Mark the region corresponding to the inset axes on ax1 and draw lines
    # in grey linking the two axes.
    mark_inset(ax, ax2, loc1=2, loc2=4, fc="none", ec='0.5')

    ax2.plot(iteration[-100:],DiffSTD[-100:], marker='.', color='r', markersize=5)
    # ax2.set_yscale('log')

    fig.savefig("AGPR_convergence.jpg", dpi=120,bbox_inches='tight')

if __name__ == '__main__':
  iterations = [0,1,2,3,488,489,490,491]
  for it in iterations:
    PlotMesh(it)
  PlotAGPR_Convergence()
