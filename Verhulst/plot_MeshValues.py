import numpy as np
import matplotlib.pyplot as plt
import pickle

def ConvertMesh_matplotlib(iteration):
    with open('AGPR/MeshValues_%04d.pkl'%iteration, 'rb') as f:
      dict = pickle.load(f)
    ParMesh = dict['Mesh']
    PosNode = dict['Elements']
    GPstd = dict['GPstdNodes']
    StdElem = dict['StdElements']
    # Mesh[i,Par] # parameter value in node i (number of parameter = 2)
    # PosNode[k,:] # nodes which generate element k
    # sigma_element[k] # value of std on element
    NumElements = PosNode.shape[0]
    # pcolormesh assignature
    # (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
    #                       +-----+
    #                       |     |
    #                       +-----+
    #     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
    # shading='flat' the dimensions of X and Y should be one greater than those of C, and the quadrilateral is colored due to the value at C[i, j]
    Par1 = np.linspace(np.min(ParMesh[:,0]),np.max(ParMesh[:,0]),int(np.sqrt(NumElements))+1) # same number of partions for each parameter
    Par2 = np.linspace(np.min(ParMesh[:,1]),np.max(ParMesh[:,1]),int(np.sqrt(NumElements))+1)
    Par1p, Par2p = np.meshgrid(Par1, Par2)
    sigma_element = np.zeros(shape=(Par1p.shape[0]-1,Par1p.shape[1]-1))

    def find_idx_close(small_array,big_array): # return idxs from big array
        return np.argwhere(
        np.isclose(small_array, big_array[:, None, :]).all(-1).any(-1)
    ).reshape(-1)
    for i in range(Par1p.shape[0]-1):
        for j in range(Par1p.shape[1]-1):
            MeshRefNode = np.array([[Par1p[i,j],Par2p[i,j]]])
            IndxNode = find_idx_close(MeshRefNode,ParMesh) # find node AGPR associate to mesh matplotlib
            IndElem = np.argwhere(IndxNode[0] == PosNode[:,0]) # find element generated by the first node in AGPR mesh
            if ( IndxNode[0] == 1106 ): print(f"{i} and {j}: Matplolib mesh: {MeshRefNode}, AGPR mesh: {ParMesh[IndxNode,:]}, Element idx: {IndElem}, Std of element {StdElem[IndElem]}")
            sigma_element[i,j] = StdElem[IndElem]
    # print(f"Max std Element: {np.argmax(StdElem)} value: {np.max(StdElem)} -- Node: {PosNode[np.argmax(StdElem),:]}")
    # print(f"Max std Element: {np.argmax(sigma_element)} -- Node: {PosNode[np.argmax(sigma_element),:]}")
    # print(f"Max std GPR: {np.argmax(GPstd)} -- Node: {ParMesh[np.argmax(GPstd),:]}")
    return Par1p,Par2p,sigma_element

def SamplesByIteraction(iteration):
    with open('AGPR/Dictionary.pkl', 'rb') as f:
      dictSamples = pickle.load(f)
    MatrixPar = dictSamples['samples_parameters']
    DiffSTD = dictSamples['difference_std']
    NumInitialSamples = MatrixPar.shape[0] - DiffSTD.shape[0]+1
    return MatrixPar[:NumInitialSamples+iteration,:]

if __name__ == '__main__':
  id_iteraction = 1
  Par1p,Par2p,sigma_element = ConvertMesh_matplotlib(id_iteraction)
  fig, ax = plt.subplots(1, 1)
  pcm = ax.pcolormesh(Par1p, Par2p, sigma_element, vmin=sigma_element.min(), vmax=sigma_element.max(), cmap='RdBu_r')
  fig.colorbar(pcm, ax=ax,label=r'$\sigma_e$')
  Samples = SamplesByIteraction(id_iteraction)
  if (id_iteraction == 0):
      ax.scatter(Samples[:,0], Samples[:,1], c='k',s=2.0, marker='o')
  else:
      ax.scatter(Samples[:-1,0], Samples[:-1,1], c='k',s=2.0, marker='o')
      ax.scatter(Samples[-1,0], Samples[-1,1], c='r',s=2.0, marker='o')
      print(Samples[-1,:])
  dt = [0.01*(np.max(Par1p) - np.min(Par1p)), 0.01*(np.max(Par2p) - np.min(Par2p))]
  plt.xlim((np.min(Par1p)-dt[0],np.max(Par1p)+dt[0]))
  plt.ylim((np.min(Par2p)-dt[1],np.max(Par2p)+dt[1]))
  plt.title(f'Iteration {id_iteraction}')
  plt.savefig('Figure_%04d.png'%id_iteraction)
  plt.show()
